/**
 * SERVIDOR MCP PRINCIPAL - TUTORIAL COMPLETO
 * 
 * Este archivo implementa un servidor MCP (Model Context Protocol) completo
 * que demuestra todos los conceptos fundamentales:
 * 
 * üîß HERRAMIENTAS (Tools): Acciones que el modelo puede ejecutar
 * üìä RECURSOS (Resources): Datos que el modelo puede leer
 * üí¨ PROMPTS: Plantillas reutilizables para interacciones
 * 
 * ¬øQU√â HACE ESTE SERVIDOR?
 * - Expone herramientas matem√°ticas, del clima, notas, etc.
 * - Proporciona acceso a una base de datos SQLite
 * - Permite lectura de archivos y recursos din√°micos
 * - Define prompts reutilizables para diferentes tareas
 */

import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { DatabaseService } from "./database/database";
import { WeatherService } from "./services/weather";
import { FileService } from "./services/files";
import { NotesService } from "./services/notes";

/**
 * PASO 1: CREAR EL SERVIDOR MCP
 * 
 * McpServer es la clase principal que maneja toda la comunicaci√≥n MCP.
 * Define el nombre y versi√≥n de nuestro servidor.
 */
const server = new McpServer({
  name: "tutorial-mcp-server",
  version: "1.0.0"
});

// Inicializar servicios
const dbService = new DatabaseService();
const weatherService = new WeatherService();
const fileService = new FileService();
const notesService = new NotesService();

/**
 * PASO 2: DEFINIR HERRAMIENTAS (TOOLS)
 * 
 * Las herramientas son ACCIONES que el modelo puede ejecutar.
 * Piensa en ellas como "funciones" que el modelo puede llamar.
 * 
 * Cada herramienta tiene:
 * - name: identificador √∫nico
 * - title: nombre mostrado al usuario
 * - description: qu√© hace la herramienta
 * - inputSchema: qu√© par√°metros necesita (validaci√≥n con Zod)
 * - handler: funci√≥n que ejecuta la acci√≥n
 */

// üßÆ HERRAMIENTA: CALCULADORA
server.registerTool(
  "calculadora",
  {
    title: "üßÆ Calculadora Matem√°tica",
    description: "Realiza operaciones matem√°ticas b√°sicas (suma, resta, multiplicaci√≥n, divisi√≥n)",
    inputSchema: {
      operacion: z.enum(["suma", "resta", "multiplicacion", "division"], {
        description: "Tipo de operaci√≥n a realizar"
      }),
      numero1: z.number({ description: "Primer n√∫mero" }),
      numero2: z.number({ description: "Segundo n√∫mero" })
    }
  },
  async ({ operacion, numero1, numero2 }) => {
    let resultado: number;
    let simbolo: string;

    switch (operacion) {
      case "suma":
        resultado = numero1 + numero2;
        simbolo = "+";
        break;
      case "resta":
        resultado = numero1 - numero2;
        simbolo = "-";
        break;
      case "multiplicacion":
        resultado = numero1 * numero2;
        simbolo = "√ó";
        break;
      case "division":
        if (numero2 === 0) {
          throw new Error("‚ùå Error: No se puede dividir por cero");
        }
        resultado = numero1 / numero2;
        simbolo = "√∑";
        break;
      default:
        throw new Error(`‚ùå Operaci√≥n no v√°lida: ${operacion}`);
    }

    return {
      content: [{
        type: "text",
        text: `üßÆ Resultado: ${numero1} ${simbolo} ${numero2} = ${resultado}`
      }]
    };
  }
);

// üå§Ô∏è HERRAMIENTA: CLIMA
server.registerTool(
  "obtener_clima",
  {
    title: "üå§Ô∏è Informaci√≥n del Clima",
    description: "Obtiene informaci√≥n meteorol√≥gica actual de cualquier ciudad",
    inputSchema: {
      ciudad: z.string({ description: "Nombre de la ciudad" }),
      pais: z.string({ description: "C√≥digo del pa√≠s (ej: ES, US)" }).optional()
    }
  },
  async ({ ciudad, pais }) => {
    try {
      const clima = await weatherService.getCurrentWeather(ciudad, pais);
      return {
        content: [{
          type: "text",
          text: `üå§Ô∏è Clima en ${clima.ciudad}:
üìç Condici√≥n: ${clima.descripcion}
üå°Ô∏è Temperatura: ${clima.temperatura}¬∞C (sensaci√≥n: ${clima.sensacionTermica}¬∞C)
üíß Humedad: ${clima.humedad}%
üí® Viento: ${clima.velocidadViento} m/s`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `‚ùå Error obteniendo clima: ${error instanceof Error ? error.message : 'Error desconocido'}`
        }],
        isError: true
      };
    }
  }
);

// üìù HERRAMIENTA: CREAR NOTA
server.registerTool(
  "crear_nota",
  {
    title: "üìù Crear Nota",
    description: "Crea una nueva nota con t√≠tulo y contenido",
    inputSchema: {
      titulo: z.string({ description: "T√≠tulo de la nota" }),
      contenido: z.string({ description: "Contenido de la nota" }),
      categoria: z.string({ description: "Categor√≠a de la nota" }).optional()
    }
  },
  async ({ titulo, contenido, categoria }) => {
    try {
      const nota = await notesService.createNote(titulo, contenido, categoria);
      return {
        content: [{
          type: "text",
          text: `üìù Nota creada exitosamente:
üÜî ID: ${nota.id}
üìã T√≠tulo: ${nota.titulo}
üìÅ Categor√≠a: ${nota.categoria || 'Sin categor√≠a'}
üìÖ Creada: ${nota.fechaCreacion}`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `‚ùå Error creando nota: ${error instanceof Error ? error.message : 'Error desconocido'}`
        }],
        isError: true
      };
    }
  }
);

// üîç HERRAMIENTA: BUSCAR NOTAS
server.registerTool(
  "buscar_notas",
  {
    title: "üîç Buscar Notas",
    description: "Busca notas por t√≠tulo, contenido o categor√≠a",
    inputSchema: {
      query: z.string({ description: "T√©rmino de b√∫squeda" }).optional(),
      categoria: z.string({ description: "Filtrar por categor√≠a" }).optional(),
      limite: z.number({ description: "N√∫mero m√°ximo de resultados" }).default(10)
    }
  },
  async ({ query, categoria, limite }) => {
    try {
      const notas = await notesService.searchNotes(query, categoria, limite);

      if (notas.length === 0) {
        return {
          content: [{
            type: "text",
            text: "üîç No se encontraron notas con los criterios especificados"
          }]
        };
      }

      const resultado = notas.map(nota =>
        `üìù **${nota.titulo}** (ID: ${nota.id})
üìÅ Categor√≠a: ${nota.categoria || 'Sin categor√≠a'}
üìÖ ${nota.fechaCreacion}
üí¨ ${nota.contenido.substring(0, 100)}${nota.contenido.length > 100 ? '...' : ''}`
      ).join('\n\n');

      return {
        content: [{
          type: "text",
          text: `üîç Encontradas ${notas.length} nota(s):\n\n${resultado}`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `‚ùå Error buscando notas: ${error instanceof Error ? error.message : 'Error desconocido'}`
        }],
        isError: true
      };
    }
  }
);

// üóÑÔ∏è HERRAMIENTA: QUERY BASE DE DATOS
server.registerTool(
  "ejecutar_sql",
  {
    title: "üóÑÔ∏è Ejecutar Query SQL",
    description: "Ejecuta consultas SQL en la base de datos (solo SELECT por seguridad)",
    inputSchema: {
      sql: z.string({ description: "Consulta SQL a ejecutar (solo SELECT)" })
    }
  },
  async ({ sql }) => {
    try {
      // Validaci√≥n de seguridad: solo permitir SELECT
      const sqlTrimmed = sql.trim().toLowerCase();
      if (!sqlTrimmed.startsWith('select')) {
        throw new Error("Por seguridad, solo se permiten consultas SELECT");
      }

      const resultados = await dbService.executeQuery(sql);

      if (resultados.length === 0) {
        return {
          content: [{
            type: "text",
            text: "üóÑÔ∏è La consulta no devolvi√≥ resultados"
          }]
        };
      }

      return {
        content: [{
          type: "text",
          text: `üóÑÔ∏è Resultados de la consulta:\n\`\`\`json\n${JSON.stringify(resultados, null, 2)}\n\`\`\``
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `‚ùå Error ejecutando consulta: ${error instanceof Error ? error.message : 'Error desconocido'}`
        }],
        isError: true
      };
    }
  }
);

/**
 * PASO 3: DEFINIR RECURSOS (RESOURCES)
 * 
 * Los recursos son DATOS que el modelo puede leer.
 * Piensa en ellos como "archivos" o "endpoints" de solo lectura.
 * 
 * Pueden ser:
 * - Est√°ticos: siempre devuelven lo mismo
 * - Din√°micos: cambian seg√∫n par√°metros
 */

// üìä RECURSO EST√ÅTICO: Informaci√≥n del servidor
server.registerResource(
  "server-info",
  "mcp://server/info",
  {
    title: "üìä Informaci√≥n del Servidor",
    description: "Informaci√≥n b√°sica sobre este servidor MCP",
    mimeType: "application/json"
  },
  async (uri) => ({
    contents: [{
      uri: uri.href,
      text: JSON.stringify({
        nombre: "Tutorial MCP Server",
        version: "1.0.0",
        descripcion: "Servidor de ejemplo para aprender MCP",
        herramientas: ["calculadora", "clima", "notas", "sql"],
        autor: "Tutorial MCP",
        fechaCreacion: new Date().toISOString()
      }, null, 2)
    }]
  })
);

// üìÅ RECURSO DIN√ÅMICO: Archivos
server.registerResource(
  "archivo",
  new ResourceTemplate("file://{ruta}", { list: undefined }),
  {
    title: "üìÅ Lector de Archivos",
    description: "Lee el contenido de archivos del sistema"
  },
  async (uri, { ruta }) => {
    try {
      // Asegurar que ruta es un string
      const rutaArchivo = Array.isArray(ruta) ? ruta[0] : ruta;
      const contenido = await fileService.readFile(rutaArchivo);
      return {
        contents: [{
          uri: uri.href,
          text: contenido
        }]
      };
    } catch (error) {
      throw new Error(`No se pudo leer el archivo: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    }
  }
);

// üìä RECURSO DIN√ÅMICO: Estad√≠sticas de base de datos
server.registerResource(
  "db-stats",
  new ResourceTemplate("db://stats/{tabla}", { list: undefined }),
  {
    title: "üìä Estad√≠sticas de Base de Datos",
    description: "Obtiene estad√≠sticas de tablas de la base de datos"
  },
  async (uri, { tabla }) => {
    try {
      // Asegurar que tabla es un string
      const nombreTabla = Array.isArray(tabla) ? tabla[0] : tabla;
      const stats = await dbService.getTableStats(nombreTabla);
      return {
        contents: [{
          uri: uri.href,
          text: JSON.stringify(stats, null, 2)
        }]
      };
    } catch (error) {
      throw new Error(`No se pudieron obtener estad√≠sticas: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    }
  }
);

/**
 * PASO 4: DEFINIR PROMPTS
 * 
 * Los prompts son PLANTILLAS reutilizables para interacciones comunes.
 * Ayudan a estandarizar c√≥mo el modelo interact√∫a con las herramientas.
 */

// üí¨ PROMPT: An√°lisis de datos
server.registerPrompt(
  "analizar_datos",
  {
    title: "üìä An√°lisis de Datos",
    description: "Plantilla para analizar datos usando las herramientas disponibles",
    argsSchema: {
      dataset: z.string({ description: "Descripci√≥n del conjunto de datos a analizar" }),
      objetivo: z.string({ description: "Objetivo del an√°lisis" }).optional()
    }
  },
  ({ dataset, objetivo }) => ({
    messages: [{
      role: "user",
      content: {
        type: "text",
        text: `Analiza el siguiente conjunto de datos: ${dataset}

${objetivo ? `Objetivo del an√°lisis: ${objetivo}` : ''}

Por favor:
1. Examina los datos disponibles usando las herramientas SQL
2. Calcula estad√≠sticas relevantes con la calculadora
3. Identifica patrones importantes
4. Proporciona insights y conclusiones
5. Crea una nota con el resumen del an√°lisis

Usa las herramientas MCP disponibles para realizar un an√°lisis completo.`
      }
    }]
  })
);

// üå§Ô∏è PROMPT: Reporte del clima
server.registerPrompt(
  "reporte_clima",
  {
    title: "üå§Ô∏è Reporte Meteorol√≥gico",
    description: "Genera un reporte completo del clima para una ubicaci√≥n",
    argsSchema: {
      ciudad: z.string({ description: "Ciudad principal para el reporte" }),
      incluir_consejos: z.string({ description: "Incluir consejos (si/no)" }).optional()
    }
  },
  ({ ciudad, incluir_consejos }) => ({
    messages: [{
      role: "user",
      content: {
        type: "text",
        text: `Genera un reporte meteorol√≥gico completo para la ciudad: ${ciudad}

Por favor:
1. Obt√©n informaci√≥n actual del clima para la ciudad
2. Analiza las condiciones meteorol√≥gicas
3. ${incluir_consejos === 'si' ? 'Proporciona consejos √∫tiles basados en las condiciones' : ''}
4. Crea una nota con el reporte completo

Usa la herramienta de clima y otras herramientas disponibles.`
      }
    }]
  })
);

/**
 * PASO 5: INICIALIZAR Y CONECTAR EL SERVIDOR
 * 
 * Finalmente, inicializamos todos los servicios y conectamos el servidor
 * usando el transporte stdio (entrada/salida est√°ndar).
 */
async function inicializarServidor() {
  try {
    console.error("üöÄ Iniciando servidor MCP...");

    // Inicializar base de datos
    await dbService.initialize();
    console.error("‚úÖ Base de datos inicializada");

    // Inicializar servicios
    await notesService.initialize();
    console.error("‚úÖ Servicio de notas inicializado");

    // Crear transporte stdio
    const transport = new StdioServerTransport();

    // Conectar servidor
    await server.connect(transport);

    console.error("üéâ Servidor MCP iniciado exitosamente!");
    console.error("üìã Herramientas disponibles: calculadora, clima, notas, SQL");
    console.error("üìä Recursos disponibles: info del servidor, archivos, estad√≠sticas DB");
    console.error("üí¨ Prompts disponibles: an√°lisis de datos, reporte del clima");

  } catch (error) {
    console.error("‚ùå Error iniciando servidor MCP:", error);
    process.exit(1);
  }
}

// Manejar cierre graceful
process.on('SIGINT', async () => {
  console.error("üõë Cerrando servidor MCP...");
  await dbService.close();
  process.exit(0);
});

// Iniciar el servidor
inicializarServidor().catch(console.error);
